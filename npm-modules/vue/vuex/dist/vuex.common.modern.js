import t from"@zkty-team/x-engine-core";function e(){return(e=Object.assign||function(t){for(var e=1;e<arguments.length;e++){var o=arguments[e];for(var r in o)Object.prototype.hasOwnProperty.call(o,r)&&(t[r]=o[r])}return t}).apply(this,arguments)}const o=("undefined"!=typeof window?window:"undefined"!=typeof global?global:{}).__VUE_DEVTOOLS_GLOBAL_HOOK__;function r(t,e=[]){if(null===t||"object"!=typeof t)return t;const o=e.filter(e=>e.original===t)[0];if(o)return o.copy;const s=Array.isArray(t)?[]:{};return e.push({original:t,copy:s}),Object.keys(t).forEach(o=>{s[o]=r(t[o],e)}),s}function s(t,e){Object.keys(t).forEach(o=>e(t[o],o))}function n(t){return null!==t&&"object"==typeof t}function i(t,e){if(!t)throw new Error(`[vuex] ${e}`)}const a="production"!==process.env.NODE_ENV;class c{constructor(t,e){this.runtime=e,this._children=Object.create(null),this._rawModule=t;const o=t.state;this.state=("function"==typeof o?o():o)||{}}get namespaced(){return!!this._rawModule.namespaced}addChild(t,e){this._children[t]=e}removeChild(t){delete this._children[t]}getChild(t){return this._children[t]}hasChild(t){return t in this._children}update(t){this._rawModule.namespaced=t.namespaced,t.actions&&(this._rawModule.actions=t.actions),t.mutations&&(this._rawModule.mutations=t.mutations),t.getters&&(this._rawModule.getters=t.getters)}forEachChild(t){s(this._children,t)}forEachGetter(t){this._rawModule.getters&&s(this._rawModule.getters,t)}forEachAction(t){this._rawModule.actions&&s(this._rawModule.actions,t)}forEachMutation(t){this._rawModule.mutations&&s(this._rawModule.mutations,t)}}class u{constructor(t){this.register([],t,!1)}get(t){return console.log("this.root",this),t.reduce((t,e)=>t.getChild(e),this.root)}getNamespace(t){let e=this.root;return t.reduce((t,o)=>(e=e.getChild(o),t+(e.namespaced?o+"/":"")),"")}update(t){l([],this.root,t)}register(t,e,o=!0){a&&d(t,e);const r=new c(e,o);0===t.length?this.root=r:this.get(t.slice(0,-1)).addChild(t[t.length-1],r),e.modules&&s(e.modules,(e,r)=>{this.register(t.concat(r),e,o)})}unregister(t){const e=this.get(t.slice(0,-1)),o=t[t.length-1],r=e.getChild(o);r?r.runtime&&e.removeChild(o):a&&console.warn(`[vuex] trying to unregister module '${o}', which is not registered`)}isRegistered(t){const e=this.get(t.slice(0,-1));return!!e&&e.hasChild(t[t.length-1])}}function l(t,e,o){if(a&&d(t,o),e.update(o),o.modules)for(const r in o.modules){if(!e.getChild(r))return void(a&&console.warn(`[vuex] trying to add a new module '${r}' on hot reloading, manual reload is needed`));l(t.concat(r),e.getChild(r),o.modules[r])}}const h={assert:t=>"function"==typeof t,expected:"function"},p={getters:h,mutations:h,actions:{assert:t=>"function"==typeof t||"object"==typeof t&&"function"==typeof t.handler,expected:'function or object with "handler" function'}};function d(t,e){Object.keys(p).forEach(o=>{if(!e[o])return;const r=p[o];s(e[o],(e,s)=>{i(r.assert(e),function(t,e,o,r,s){let n=`${e} should be ${s} but "${e}.${o}"`;return t.length>0&&(n+=` in module "${t.join(".")}"`),n+=` is ${JSON.stringify(r)}.`,n}(t,o,s,e,r.expected))})})}let m;class f{constructor(r={}){!m&&"undefined"!=typeof window&&window.Vue&&$(window.Vue),a&&(i(m,"must call Vue.use(Vuex) before creating a store instance."),i("undefined"!=typeof Promise,"vuex requires a Promise polyfill in this browser."),i(this instanceof f,"store must be called with the new operator."));const{plugins:s=[],strict:n=!1}=r;let c=t.api("com.zkty.jsi.vuex","get","store");if(c&&"modules"in r){const t=JSON.parse(c);Object.keys(r.modules).forEach(o=>{r.modules[o].state=e({},r.modules[o].state,t[o])})}this._committing=!1,this._actions=Object.create(null),this._actionSubscribers=[],this._mutations=Object.create(null),this._wrappedGetters=Object.create(null),this._modules=new u(r),this._modulesNamespaceMap=Object.create(null),this._subscribers=[],this._watcherVM=new m,this._makeLocalGettersCache=Object.create(null);const l=this,{dispatch:h,commit:p}=this;this.dispatch=function(t,e){return h.call(l,t,e)},this.commit=function(t,e,o){return p.call(l,t,e,o)},this.strict=n;let d=this._modules.root.state;c?d=JSON.parse(c):d&&t.api("com.zkty.jsi.vuex","set",{key:"store",val:JSON.stringify(d)}),b(this,d,[],this._modules.root),_(this,d),s.forEach(t=>t(this)),t.platform.isPc||(this._subscribers.push((e,o)=>{t.api("com.zkty.jsi.vuex","set",{key:"store",val:JSON.stringify(o)})}),t.broadcastOn((t,e)=>{if("@@VUEX_STORE_EVENT"===t){let t=JSON.parse(e);Object.keys(this._vm._data.$$state).forEach(e=>{this._vm._data.$$state[e]=t[e]})}})),(void 0!==r.devtools?r.devtools:m.config.devtools)&&function(t){o&&(t._devtoolHook=o,o.emit("vuex:init",t),o.on("vuex:travel-to-state",e=>{t.replaceState(e)}),t.subscribe((t,e)=>{o.emit("vuex:mutation",t,e)},{prepend:!0}),t.subscribeAction((t,e)=>{o.emit("vuex:action",t,e)},{prepend:!0}))}(this)}get state(){return this._vm._data.$$state}set state(t){a&&i(!1,"use store.replaceState() to explicit replace store state.")}commit(t,e,o){const{type:r,payload:s,options:n}=w(t,e,o),i={type:r,payload:s},c=this._mutations[r];c?(this._withCommit(()=>{c.forEach(function(t){t(s)})}),this._subscribers.slice().forEach(t=>t(i,this.state)),a&&n&&n.silent&&console.warn(`[vuex] mutation type: ${r}. Silent option has been removed. Use the filter functionality in the vue-devtools`)):a&&console.error(`[vuex] unknown mutation type: ${r}`)}dispatch(t,e){const{type:o,payload:r}=w(t,e),s={type:o,payload:r},n=this._actions[o];if(!n)return void(a&&console.error(`[vuex] unknown action type: ${o}`));try{this._actionSubscribers.slice().filter(t=>t.before).forEach(t=>t.before(s,this.state))}catch(t){a&&(console.warn("[vuex] error in before action subscribers: "),console.error(t))}const i=n.length>1?Promise.all(n.map(t=>t(r))):n[0](r);return new Promise((t,e)=>{i.then(e=>{try{this._actionSubscribers.filter(t=>t.after).forEach(t=>t.after(s,this.state))}catch(t){a&&(console.warn("[vuex] error in after action subscribers: "),console.error(t))}t(e)},t=>{try{this._actionSubscribers.filter(t=>t.error).forEach(e=>e.error(s,this.state,t))}catch(t){a&&(console.warn("[vuex] error in error action subscribers: "),console.error(t))}e(t)})})}subscribe(t,e){return g(t,this._subscribers,e)}subscribeAction(t,e){return g("function"==typeof t?{before:t}:t,this._actionSubscribers,e)}watch(t,e,o){return a&&i("function"==typeof t,"store.watch only accepts a function."),this._watcherVM.$watch(()=>t(this.state,this.getters),e,o)}replaceState(t){this._withCommit(()=>{this._vm._data.$$state=t})}registerModule(t,e,o={}){"string"==typeof t&&(t=[t]),a&&(i(Array.isArray(t),"module path must be a string or an Array."),i(t.length>0,"cannot register the root module by using registerModule.")),this._modules.register(t,e),b(this,this.state,t,this._modules.get(t),o.preserveState),_(this,this.state)}unregisterModule(t){"string"==typeof t&&(t=[t]),a&&i(Array.isArray(t),"module path must be a string or an Array."),this._modules.unregister(t),this._withCommit(()=>{const e=v(this.state,t.slice(0,-1));m.delete(e,t[t.length-1])}),y(this)}hasModule(t){return"string"==typeof t&&(t=[t]),a&&i(Array.isArray(t),"module path must be a string or an Array."),this._modules.isRegistered(t)}hotUpdate(t){this._modules.update(t),y(this,!0)}_withCommit(t){const e=this._committing;this._committing=!0,t(),this._committing=e}}function g(t,e,o){return e.indexOf(t)<0&&(o&&o.prepend?e.unshift(t):e.push(t)),()=>{const o=e.indexOf(t);o>-1&&e.splice(o,1)}}function y(t,e){t._actions=Object.create(null),t._mutations=Object.create(null),t._wrappedGetters=Object.create(null),t._modulesNamespaceMap=Object.create(null);const o=t.state;b(t,o,[],t._modules.root,!0),_(t,o,e)}function _(t,e,o){const r=t._vm;t.getters={},t._makeLocalGettersCache=Object.create(null);const n={};s(t._wrappedGetters,(e,o)=>{n[o]=function(t,e){return function(){return t(e)}}(e,t),Object.defineProperty(t.getters,o,{get:()=>t._vm[o],enumerable:!0})});const c=m.config.silent;m.config.silent=!0,t._vm=new m({data:{$$state:e},computed:n}),m.config.silent=c,t.strict&&function(t){t._vm.$watch(function(){return this._data.$$state},()=>{a&&i(t._committing,"do not mutate vuex store state outside mutation handlers.")},{deep:!0,sync:!0})}(t),r&&(o&&t._withCommit(()=>{r._data.$$state=null}),m.nextTick(()=>r.$destroy()))}function b(t,e,o,r,s){const n=!o.length,i=t._modules.getNamespace(o);if(r.namespaced&&(t._modulesNamespaceMap[i]&&a&&console.error(`[vuex] duplicate namespace ${i} for the namespaced module ${o.join("/")}`),t._modulesNamespaceMap[i]=r),!n&&!s){const s=v(e,o.slice(0,-1)),n=o[o.length-1];t._withCommit(()=>{a&&n in s&&console.warn(`[vuex] state field "${n}" was overridden by a module with the same name at "${o.join(".")}"`),m.set(s,n,r.state)})}const c=r.context=function(t,e,o){const r=""===e,s={dispatch:r?t.dispatch:(o,r,s)=>{const n=w(o,r,s),{payload:i,options:c}=n;let{type:u}=n;if(c&&c.root||(u=e+u,!a||t._actions[u]))return t.dispatch(u,i);console.error(`[vuex] unknown local action type: ${n.type}, global type: ${u}`)},commit:r?t.commit:(o,r,s)=>{const n=w(o,r,s),{payload:i,options:c}=n;let{type:u}=n;c&&c.root||(u=e+u,!a||t._mutations[u])?t.commit(u,i,c):console.error(`[vuex] unknown local mutation type: ${n.type}, global type: ${u}`)}};return Object.defineProperties(s,{getters:{get:r?()=>t.getters:()=>function(t,e){if(!t._makeLocalGettersCache[e]){const o={},r=e.length;Object.keys(t.getters).forEach(s=>{if(s.slice(0,r)!==e)return;const n=s.slice(r);Object.defineProperty(o,n,{get:()=>t.getters[s],enumerable:!0})}),t._makeLocalGettersCache[e]=o}return t._makeLocalGettersCache[e]}(t,e)},state:{get:()=>v(t.state,o)}}),s}(t,i,o);r.forEachMutation((e,o)=>{!function(t,e,o,r){(t._mutations[e]||(t._mutations[e]=[])).push(function(e){o.call(t,r.state,e)})}(t,i+o,e,c)}),r.forEachAction((e,o)=>{!function(t,e,o,r){(t._actions[e]||(t._actions[e]=[])).push(function(e){let s=o.call(t,{dispatch:r.dispatch,commit:r.commit,getters:r.getters,state:r.state,rootGetters:t.getters,rootState:t.state},e);var n;return(n=s)&&"function"==typeof n.then||(s=Promise.resolve(s)),t._devtoolHook?s.catch(e=>{throw t._devtoolHook.emit("vuex:error",e),e}):s})}(t,e.root?o:i+o,e.handler||e,c)}),r.forEachGetter((e,o)=>{!function(t,e,o,r){t._wrappedGetters[e]?a&&console.error(`[vuex] duplicate getter key: ${e}`):t._wrappedGetters[e]=function(t){return o(r.state,r.getters,t.state,t.getters)}}(t,i+o,e,c)}),r.forEachChild((r,n)=>{b(t,e,o.concat(n),r,s)})}function v(t,e){return e.reduce((t,e)=>t[e],t)}function w(t,e,o){return n(t)&&t.type&&(o=e,e=t,t=t.type),a&&i("string"==typeof t,`expects string as the type, but found ${typeof t}.`),{type:t,payload:e,options:o}}function $(t){m&&t===m?a&&console.error("[vuex] already installed. Vue.use(Vuex) should be called only once."):(m=t,function(t){if(Number(t.version.split(".")[0])>=2)t.mixin({beforeCreate:e});else{const o=t.prototype._init;t.prototype._init=function(t={}){t.init=t.init?[e].concat(t.init):e,o.call(this,t)}}function e(){const t=this.$options;t.store?this.$store="function"==typeof t.store?t.store():t.store:t.parent&&t.parent.$store&&(this.$store=t.parent.$store)}}(m))}const x=C((t,e)=>{const o={};return a&&!M(e)&&console.error("[vuex] mapState: mapper parameter must be either an Array or an Object"),k(e).forEach(({key:e,val:r})=>{o[e]=function(){let e=this.$store.state,o=this.$store.getters;if(t){const r=S(this.$store,"mapState",t);if(!r)return;e=r.context.state,o=r.context.getters}return"function"==typeof r?r.call(this,e,o):e[r]},o[e].vuex=!0}),o}),O=C((t,e)=>{const o={};return a&&!M(e)&&console.error("[vuex] mapMutations: mapper parameter must be either an Array or an Object"),k(e).forEach(({key:e,val:r})=>{o[e]=function(...e){let o=this.$store.commit;if(t){const e=S(this.$store,"mapMutations",t);if(!e)return;o=e.context.commit}return"function"==typeof r?r.apply(this,[o].concat(e)):o.apply(this.$store,[r].concat(e))}}),o}),j=C((t,e)=>{const o={};return a&&!M(e)&&console.error("[vuex] mapGetters: mapper parameter must be either an Array or an Object"),k(e).forEach(({key:e,val:r})=>{r=t+r,o[e]=function(){if(!t||S(this.$store,"mapGetters",t)){if(!a||r in this.$store.getters)return this.$store.getters[r];console.error(`[vuex] unknown getter: ${r}`)}},o[e].vuex=!0}),o}),E=C((t,e)=>{const o={};return a&&!M(e)&&console.error("[vuex] mapActions: mapper parameter must be either an Array or an Object"),k(e).forEach(({key:e,val:r})=>{o[e]=function(...e){let o=this.$store.dispatch;if(t){const e=S(this.$store,"mapActions",t);if(!e)return;o=e.context.dispatch}return"function"==typeof r?r.apply(this,[o].concat(e)):o.apply(this.$store,[r].concat(e))}}),o}),A=t=>({mapState:x.bind(null,t),mapGetters:j.bind(null,t),mapMutations:O.bind(null,t),mapActions:E.bind(null,t)});function k(t){return M(t)?Array.isArray(t)?t.map(t=>({key:t,val:t})):Object.keys(t).map(e=>({key:e,val:t[e]})):[]}function M(t){return Array.isArray(t)||n(t)}function C(t){return(e,o)=>("string"!=typeof e?(o=e,e=""):"/"!==e.charAt(e.length-1)&&(e+="/"),t(e,o))}function S(t,e,o){const r=t._modulesNamespaceMap[o];return a&&!r&&console.error(`[vuex] module namespace not found in ${e}(): ${o}`),r}function N({collapsed:t=!0,filter:e=((t,e,o)=>!0),transformer:o=(t=>t),mutationTransformer:s=(t=>t),actionFilter:n=((t,e)=>!0),actionTransformer:i=(t=>t),logMutations:a=!0,logActions:c=!0,logger:u=console}={}){return l=>{let h=r(l.state);void 0!==u&&(a&&l.subscribe((n,i)=>{const a=r(i);if(e(n,h,a)){const e=P(),r=s(n);G(u,`mutation ${n.type}${e}`,t),u.log("%c prev state","color: #9E9E9E; font-weight: bold",o(h)),u.log("%c mutation","color: #03A9F4; font-weight: bold",r),u.log("%c next state","color: #4CAF50; font-weight: bold",o(a)),V(u)}h=a}),c&&l.subscribeAction((e,o)=>{if(n(e,o)){const o=P(),r=i(e);G(u,`action ${e.type}${o}`,t),u.log("%c action","color: #03A9F4; font-weight: bold",r),V(u)}}))}}function G(t,e,o){const r=o?t.groupCollapsed:t.group;try{r.call(t,e)}catch(o){t.log(e)}}function V(t){try{t.groupEnd()}catch(e){t.log("—— log end ——")}}function P(){const t=new Date;return` @ ${L(t.getHours(),2)}:${L(t.getMinutes(),2)}:${L(t.getSeconds(),2)}.${L(t.getMilliseconds(),3)}`}function L(t,e){return o=e-t.toString().length,new Array(o+1).join("0")+t;var o}var H={Store:f,install:$,version:"__VERSION__",mapState:x,mapMutations:O,mapGetters:j,mapActions:E,createNamespacedHelpers:A,createLogger:N};export default H;export{f as Store,N as createLogger,A as createNamespacedHelpers,$ as install,E as mapActions,j as mapGetters,O as mapMutations,x as mapState};
